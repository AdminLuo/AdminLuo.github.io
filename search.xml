<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/12/19/docker/</url>
    <content><![CDATA[<h3 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h3><p>DevOps： 开发运维</p>
<p>本质：所有的技术都是因为出现了问题，我们需要去解决，才去学习</p>
<p>Docker的思想就来自于集装箱</p>
<p>开发—-运维</p>
<p>传统 开发人员开发一个jar给运维人员，运维人员去搭建环境</p>
<p>现在 开发人员将环境和jar文件打包部署上线，一套流程做完（使用docker）</p>
<p>例如 使用java写一款apk， 发布到应用商店  某人在应用商店安装apk—-安装即可用</p>
<p>但是 使用java  写一个jar  （环境）  之后可以带上环境打包项目（称之位镜像） —- 将镜像存放到Docker仓库（商店）  其他人可以下载我们所发布的镜像直接运行即可</p>
<p>如果在操作系统中运行java的时候产生了端口冲突等等情况，则会导致报错</p>
<p>Docker的核心思想是  隔离  </p>
<p>每个镜像（”箱子“）都是互相隔离的</p>
<p>而Docker 通过隔离机制可以将服务器利用到极致</p>
<p>Docker是基于go语言开发的</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200929132330451.png" alt="image-20200929132330451"></p>
<h4 id="Docker能干什么"><a href="#Docker能干什么" class="headerlink" title="Docker能干什么"></a>Docker能干什么</h4><p>容器化技术不是模拟的完整的操作系统  只需要其核心</p>
<p>虚拟机技术：<img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200929132435695.png" alt="image-20200929132435695"></p>
<p>传统虚拟机：虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p>
<p>Docker技术：</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200929132454471.png" alt=""></p>
<p>容器内应用直接运行在宿主机的内核上，容器没有自己的内核，也没有虚拟硬件 因此非常轻便，每个容器间是互相隔离的，每个容器内都有属于自己的文件系统，互不影响</p>
<p>应用更快速的交付和部署</p>
<p>传统 ：  有很多帮助文档，安装很麻烦</p>
<p>Docker：打包镜像发布测试，可以一键运行</p>
<p>更便捷的升级和扩缩容</p>
<p>更简单的系统运维</p>
<p>在容器化之后，我们的开发、测试环境都是高度一致的</p>
<p>更高效的计算资源利用</p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多容器实例</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200929132529058.png" alt="image-20200929132529058"></p>
<p><strong>镜像（**</strong>image**）</p>
<p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务</p>
<p>tomcat镜像  ===&gt;  run  ==&gt;  tomcat01容器（提供服务器）</p>
<p>通过这些镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）</p>
<p><strong>容器（container）</strong></p>
<p>Docker利用容器技术，独立运行一个或者一个组应用（通过镜像来创建的）</p>
<p>可以将这个容器理解为一个简易的Linux操作系统</p>
<p><strong>仓库（repository）</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>分为私有仓库和公有仓库</p>
<p>Docker Hub 默认是国外的</p>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><p>在centos7上:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、先卸载以前安装的旧版本：</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta">#</span><span class="bash">2、下载需要安装的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  #该地址是国外的，下载的时候很慢</span><br><span class="line"><span class="meta">	#</span><span class="bash">建议使用国内地址：</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    #更新软件包的索引：</span><br><span class="line">    yum makecache fast</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">4、安装docker的相关内容   docker-ce为社区版   docoer-ee为企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5、启动docker</span></span><br><span class="line">systemctl start docker  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6、可以使用docker version  来查看docker的版本</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918150317514.png" alt="image-20200918150317514"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、运行hello-world</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">没有hello-world  去官方网站下的library目录下pull（拉取）</span><br><span class="line">拉取到之后会有一个签名信息代表其拉取成功</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918151357337.png" alt="image-20200918151357337"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">8、查看下载的hello-world 镜像</span></span><br><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        8 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<p>卸载docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash">2、删除资源</span></span><br><span class="line">rm -rf /var/lib/docker    #/var/lib/docker为docker的默认安装路径</span><br></pre></td></tr></table></figure>
<h4 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h4><p>详情看视频：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=7">https://www.bilibili.com/video/BV1og4y1q7M4?p=7</a></p>
<h4 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h4><p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918153921184.png" alt="image-20200918153921184"></p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p><strong>Docker是怎么工作的</strong></p>
<p>Docker  是一个Client-Server 结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问</p>
<p>DockerServer  接收到  Docker-Client的指令，就会执行这个命令</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918155005871.png" alt="image-20200918155005871"></p>
<p><strong>Docker 为什么比  Vmware快：</strong></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918155115989.png" alt="image-20200918155115989"></p>
<p>（其中   host OS  代表主机）</p>
<p>1、Docker有着比虚拟机更少的抽象层</p>
<p>2、Doucker使用的是物理机的内核，而Vmware需要的是Guest OS，所以说，新建一个容器的时候，Docker不需要想虚拟机一样重新加载一个虚拟机的内核，避免引导性操作。虚拟机时加载Guest OS   （分钟级别）  而Docker 时利用物理机（宿主机）的操作系统，省略了复杂的过程（秒级）</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918155719247.png" alt="image-20200918155719247"></p>
<h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><hr>
<h4 id="Docker帮助命令"><a href="#Docker帮助命令" class="headerlink" title="Docker帮助命令"></a>Docker帮助命令</h4><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version  #查看docker版本信息</span><br><span class="line">docker info     #查看docker系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令  --help  #查看命令帮助信息</span><br></pre></td></tr></table></figure>
<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline">https://docs.docker.com/engine/reference/commandline</a></p>
<h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p><strong>docker images </strong>  查看所有本地的主机上的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        8 months ago        13.3kB</span><br><span class="line"></span><br><span class="line">REPOSITORY	镜像的仓库源</span><br><span class="line">TAG			镜像的标签</span><br><span class="line">IMAGE ID	镜像的标签</span><br><span class="line">CREATED		镜像的创建时间</span><br><span class="line">SIZE		镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可选项</span></span><br><span class="line">  -a, --all             列出所有镜像  Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           只显示镜像的id   #  Only show numeric IDs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>docker search 搜索镜像</strong></p>
<p>使用filter来过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker search mysql --filter=STARS=3000</span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql               MySQL is a widely used, open-source relation…   9969                [OK]                </span><br><span class="line">mariadb             MariaDB is a community-developed fork of MyS…   3648                [OK]   </span><br></pre></td></tr></table></figure>
<p><strong>docker pull</strong>  下载镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker pull mysql  后面可以使用[:tag]来指定安装的版本</span><br><span class="line">Using default tag: latest	#如果不写 tag   默认就时安装latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">d121f8d1c412: Pull complete   #分层下载，docker image的核心    联合了文件系统</span><br><span class="line">f3cebc0b4691: Pull complete </span><br><span class="line">1862755a0b37: Pull complete </span><br><span class="line">489b44f3dbb4: Pull complete </span><br><span class="line">690874f836db: Pull complete </span><br><span class="line">baa8be383ffb: Pull complete </span><br><span class="line">55356608b4ac: Pull complete </span><br><span class="line">dd35ceccb6eb: Pull complete </span><br><span class="line">429b35712b19: Downloading  105.7MB/112.5MB</span><br><span class="line">162d8291095c: Download complete </span><br><span class="line">5e500ef7181b: Download complete </span><br><span class="line">af7528e958b6: Download complete </span><br><span class="line">Digest : sha256:dc255....................(以上内容省略)   #数字签名</span><br><span class="line">Status:Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql：latest   #真实地址</span><br><span class="line"></span><br><span class="line">docker pull mysql    等价于  docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指定版本的时候必须要该版本在官方文档中存在：</span><br><span class="line">docker pull mysql[:5.7]  #指定安装5.7的版本</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200918191632958.png" alt="image-20200918191632958"></p>
<p><strong>docker rmi</strong>  删除镜像（rm  ：  删除   i代表镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除镜像的时候可以通过镜像id删除，也可以通过镜像名称来删除</span></span><br><span class="line">[root@localhost /]docker rmi -f 镜像id   # 删除指定id的镜像 </span><br><span class="line">[root@localhost /]docker rmi -f 镜像id 镜像id 镜像id 镜像id  # 可以删除多个镜像</span><br><span class="line">[root@localhost /]docker rmi -f $(docker images -aq)   # 删除全部的容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><p><strong>说明：我们有了镜像才可以创建容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line"></span><br><span class="line">[root@localhost /]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">3c72a8ed6814: Pull complete </span><br><span class="line">Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数]  image</span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;		容器名字 tomcat01  tomcat01，用来区分容器</span><br><span class="line">-d					后台方式运行</span><br><span class="line">-it					指定交互方式运行，进入容器查看内容</span><br><span class="line">-p					指定容器的端口 -p 8080:8080</span><br><span class="line">	-p ip:主机端口:容器端口</span><br><span class="line">	-p 主机端口:容器端口     #（最常用的一种）</span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-p					随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试，启动并进入容器</span></span><br><span class="line">[root@localhost /]# docker run -it centos /bin/bash</span><br><span class="line">[root@75594955edd7 /]# ls  #查看容器内的centos，与外部的没有关系</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">容器内其实就是自己的一个环境</span><br><span class="line"><span class="meta">#</span><span class="bash">其中 75594955edd7  为 容器id</span></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器中退回至主机</span></span><br><span class="line">[root@75594955edd7 /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker ps 命令</span></span><br><span class="line">不加任何参数 #列出当前正在运行的容器   +1</span><br><span class="line">-a		   #列出当前运行的容器   和   历史运行过的容器</span><br><span class="line">-n=？   	  # 显示最近创建的容器（指定个数）</span><br><span class="line">-q 		   # 只显示容器的编号</span><br><span class="line"></span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@localhost /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">75594955edd7        centos              &quot;/bin/bash&quot;         31 minutes ago      Exited (0) 19 minutes ago                       hardcore_jang</span><br><span class="line">12cce6bbf0ac        bf756fb1ae65        &quot;/hello&quot;            6 hours ago         Exited (0) 6 hours ago                          xenodochial_feynman</span><br><span class="line">[root@localhost /]# docker ps -aq</span><br><span class="line">75594955edd7</span><br><span class="line">12cce6bbf0ac</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit  # 直接停止容器并退出</span><br><span class="line">Ctrl +  P  +  Q   #容器不停止退出</span><br></pre></td></tr></table></figure>
<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id		#删除指定的容器，不能删除正在运行的容器，需要强制删除  rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)	#删除所有的容器   （-f  是强制删除）</span><br><span class="line">docker ps -a -q | xargs docker rm #删除所有的容器</span><br></pre></td></tr></table></figure>
<p><strong>启动和停止容器的操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id	#启动容器</span><br><span class="line">dockers restart 容器id  #重启容器</span><br><span class="line">docker stop 容器id   #停止当前正在运行的容器</span><br><span class="line">docker kill 容器id	#强制停止（只能停止正在运行的容器）</span><br></pre></td></tr></table></figure>
<h4 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h4><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令docker run -d 镜像名</span></span><br><span class="line">[root@localhost ~]# docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当使用docker ps 的时候，发现  centos 停止了</span></span><br><span class="line"></span><br><span class="line">原因：docker容器在后台运行时，必须有一个前台进程，当docker发现没有应用的时候，就会自动停止</span><br><span class="line"><span class="meta">#</span><span class="bash">nginx   容器启动后没发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>
<p><strong>日志命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker logs --help</span><br><span class="line">Usage:	docker logs [OPTIONS] CONTAINER</span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">      </span><br><span class="line">docker logs -f -t   容器id#  查看所有的日志信息</span><br></pre></td></tr></table></figure>
<p><strong>shell编程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c		往里面写脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker run -d centos /bin/sh -c &quot;while true;do echo adminluo;sleep 1;done&quot;   #脚本内容和命令</span><br><span class="line">1518e665bc039905ab70f4293a8aea7477d5c351458defd5c6858dc8bf7e2922</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 </span><br><span class="line">1518e665bc03        centos    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示日志</span></span><br><span class="line">docker logs -f -t --tail  容器id</span><br><span class="line"></span><br><span class="line">--tatl  条数   #可以查看指定条数的日志，之后会一致打印</span><br></pre></td></tr></table></figure>
<p><strong>查看容器中的进程信息    在Linux中使用ps查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker top a0fde7c70ff5</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY     </span><br><span class="line">root                1619                1601                0                   9月19                pts/0   </span><br></pre></td></tr></table></figure>
<p><strong>查看镜像元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">*******************************************************************************************************</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker inspect a0fde7c70ff5</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-09-19T15:45:56.012499301Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 1619,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2020-09-19T15:45:56.447461022Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464/a0fde7c70ff57298d01ac3f2c4e8e69255750b898aea6de574cf452067a31464-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/admiring_cray&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;Capabilities&quot;: null,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/451d8726897aa1cd0dc868048e16d636c8a173e337a41dea7d00c38226cf4a95-init/diff:/var/lib/docker/overlay2/fc936bee709b8fa91a06b278c9d89dd521ca6e06943694740d8d0327095d93b5/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/451d8726897aa1cd0dc868048e16d636c8a173e337a41dea7d00c38226cf4a95/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/451d8726897aa1cd0dc868048e16d636c8a173e337a41dea7d00c38226cf4a95/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/451d8726897aa1cd0dc868048e16d636c8a173e337a41dea7d00c38226cf4a95/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;a0fde7c70ff5&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: true,</span><br><span class="line">            &quot;AttachStdout&quot;: true,</span><br><span class="line">            &quot;AttachStderr&quot;: true,</span><br><span class="line">            &quot;Tty&quot;: true,</span><br><span class="line">            &quot;OpenStdin&quot;: true,</span><br><span class="line">            &quot;StdinOnce&quot;: true,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;9e022abafa3557d84e31eec697f58d66ba509e054256efa9c8a4a12ea2337d28&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/9e022abafa35&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;5c9eaef03e4e93c9601ed900a3dc918c51838b46be3c6de2f4f006e1f92c738a&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;d0a7bd76c17d0bf2769f34b9565e51a3ee105a65dbfecc9cff0316ceb798ffee&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;5c9eaef03e4e93c9601ed900a3dc918c51838b46be3c6de2f4f006e1f92c738a&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方式一</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令   docker <span class="built_in">exec</span> -it 容器id bashshell   【it是以交互模式运行，bashshel是容器运行的环境】</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker exec -it a9912c6c820a /bin/bash</span><br><span class="line">[root@a9912c6c820a /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@a9912c6c820a /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 01:01 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         14      0  0 01:02 pts/1    00:00:00 /bin/bash</span><br><span class="line">root         28     14  0 01:07 pts/1    00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">[root@localhost ~]# docker attach a9912c6c820a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">exec</span>    是进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker attach  进入容器正在执行的终端，不会开启新的进程</span> </span><br></pre></td></tr></table></figure>
<p><strong>拷贝文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令： </span><br><span class="line">docker cp 容器id : 文件在容器中的路径 文件在容器外的路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在容器中的操作，新建一个文件</span></span><br><span class="line">[root@a9912c6c820a bin]#     </span><br><span class="line">[root@a9912c6c820a bin]# cd /home</span><br><span class="line">[root@a9912c6c820a home]# ls</span><br><span class="line">[root@a9912c6c820a home]# touch testfile.php</span><br><span class="line">[root@a9912c6c820a home]# ls</span><br><span class="line">testfile.php</span><br><span class="line">[root@a9912c6c820a home]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">a9912c6c820a        centos              &quot;/bin/bash&quot;         34 minutes ago      Exited (0) 14 seconds ago                       zen_wescoff</span><br><span class="line">a0fde7c70ff5        centos              &quot;/bin/bash&quot;         10 hours ago        Exited (0) 9 hours ago                          admiring_cray</span><br><span class="line">d9a2afc6dfc2        centos              &quot;/bin/bash&quot;         10 hours ago        Exited (0) 10 hours ago                         kind_neumann</span><br><span class="line">10d6efd94957        centos              &quot;/bin/bash&quot;         36 hours ago        Exited (0) 36 hours ago                         nice_black</span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝命令</span></span><br><span class="line">[root@localhost ~]# docker cp a9912c6c820a:/home/testfile.php /home</span><br><span class="line">[root@localhost ~]# cd home</span><br><span class="line">-bash: cd: home: 没有那个文件或目录</span><br><span class="line">[root@localhost ~]# cd /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">luo  st  test1  test2  testfile.php  user1  user2  user3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝是一个手动过程   以后可以使用-v  卷的技术，可以实现自动同步</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200920100917924.png" alt="image-20200920100917924"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200920101012879.png" alt="image-20200920101012879"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200920101028885.png" alt="image-20200920101028885"></p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>将80端口映射到某一个端口  通过公网的该端口可以访问到docker 的8080</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3344:80 -d --name nginx01 nginx</span><br><span class="line">e82bb004cea5841ce2acc3f1f65ef815cc20e11df9618b13822bdf8ea932b509</span><br><span class="line"><span class="meta">#</span><span class="bash">-d   后台运行   --name   指定容器名字    -p 宿主机端口:容器内部端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用-P（大写）标记时，docker会随机选择一个端口映射到容器内部开放的网络端口上。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                  NAMES</span><br><span class="line">e82bb004cea5        nginx               &quot;/docker-entrypoint.…&quot;   9 seconds ago       Up 9 seconds                0.0.0.0:3344-&gt;80/tcp   nginx01</span><br><span class="line">6f146625b78e        centos              &quot;/bin/bash&quot;              About an hour ago   Exited (0) 14 minutes ago                          gifted_panini</span><br><span class="line">[root@localhost ~]# curl http://localhost:3344</span><br><span class="line"><span class="meta">#</span><span class="bash">curl   查看url的状况，发送一个请求</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@e82bb004cea5:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换到Linux下，查看端口占用状况</span></span><br><span class="line">[root@localhost ~]# netstat -an |grep 3344</span><br><span class="line">tcp6       0      0 :::3344                 :::*                    LISTEN</span><br></pre></td></tr></table></figure>
<p><strong>[Docker容器内部端口映射到外部宿主机端口]</strong></p>
<p>参考以下文章：</p>
<p><a href="https://www.cnblogs.com/kevingrace/p/9453987.html">https://www.cnblogs.com/kevingrace/p/9453987.html</a></p>
<blockquote>
<p><strong>部署tomcat</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta">#</span><span class="bash">  -- rm  解析：  我们之前的启动都是在后台，停止了容器之后，容器还是可以查到.而--rm  一般用来测试，用完就删除（删除容器，但是镜像还在）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载之后启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">[root@localhost ~]# docker run -d --name tomcat01 -p 3355:8080 tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash">该状况从外界访问会出现404错误</span></span><br><span class="line"><span class="meta">#</span><span class="bash">*****************************************************************************************</span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">[root@localhost ~]# docker exec -it d5e5ab099f868fff524d54a19eec52598607e5ce962b38672f3eda6a54cdd235 /bin/bash</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt  CONTRIBUTING.md  LICENSE	NOTICE	README.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat# cd webapps</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat/webapps# ls</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat/webapps# cd ..</span><br><span class="line"><span class="meta">#</span><span class="bash">将webapps.dist中的所有文件全部移动到webapps中</span></span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat# cp -r webapps.dist/* webapps   #-r  递归copy</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat# cd webapps</span><br><span class="line">root@d5e5ab099f86:/usr/local/tomcat/webapps# ls</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line"><span class="meta">#</span><span class="bash">可以正常访问</span></span><br></pre></td></tr></table></figure>
<p>部署  es  +  kibana</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">es: elasticsearch6 搜索引擎</span><br><span class="line">kibana:es的可视化操作界面</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">es  暴露的端口很多</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es  十分的耗内存 （全文搜索引擎）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es  的数据一般需要放置到安全目录   挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--net somenetwork   为  网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动elasticsearch</span></span><br><span class="line">docker run -d --name elasticserch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921134245569.png" alt="image-20200921134245569"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921134306725.png" alt="image-20200921134306725"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker status  查看容器的资源占用情况</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921135123078.png" alt="image-20200921135123078"></p>
<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><ul>
<li><p>portainer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure></li>
<li>Rancher  (CI/CD再用)</li>
</ul>
<p>什么是portainer？</p>
<p>Dokcer图形化界面管理工具，提供一个后台面板供我们操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><h4 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h4><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件</p>
<p>所有的应用，直接打包docker镜像，就可以直接跑起来</p>
<p><strong>如何得到镜像：</strong></p>
<ul>
<li>远程仓库下载</li>
<li>从别人那里拷贝</li>
<li>自己制作一个镜像dockerfile</li>
</ul>
<p>例如：</p>
<p>tomcat  和   mysql   ，其中mysql需要使用centos，如果下载了centos，那么tomcat就不需要再下载了，可以直接使用mysql的centos</p>
<h4 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h4><blockquote>
<p><strong>（1）UnionFS(联合文件系统)</strong></p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union文件系统是Dokcer镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统加载起来，这样最终的文件系统会包含所有的底层文件和目录</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921213956866.png" alt="image-20200921213956866"></p>
<blockquote>
<p> <strong>（2）Docker镜像加载原理</strong></p>
</blockquote>
<p>docker的镜像实际上是由一层一层的文件系统构成，这种层级的文件系统UnionFS。</p>
<p>主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的linux/unix系统是一样的，包含boot加载器内核。当boot加载完之后整个内核就都在内存中了，此时内存的使用权已经由bootfs交给内核了，此时系统也会卸载bootfs</p>
<p>对以一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就行，因为底层直接用host和kernel，自己只需要提供rootfs就行。由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p>
<p><strong>由于上述原因，Docker的启动时秒级，而虚拟机的启动时分钟级别</strong></p>
<p>可以使用docker image inspect 容器名  查看容器的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">        &quot;Layers&quot;: [</span><br><span class="line">            &quot;sha256:4ef54afed7804a44fdeb8cf6562c2a1eb745dcaabd38b1ac60126f0966bf6aef&quot;,</span><br><span class="line">            &quot;sha256:6add0d2b5482578ccb2eeed7d7dac7c4c258722884db7e69c1739fd9f69a93dc&quot;,</span><br><span class="line">            &quot;sha256:d37096232ed8372a371df462c953a61381c8a62424eebd8d260941a5473b0957&quot;,</span><br><span class="line">            &quot;sha256:17bdf5e22660221184ed52356cf4e74d5c4cd0af9ad6326c4f683b15b41621d4&quot;,</span><br><span class="line">            &quot;sha256:df95ed2a791dcc795f8bb4868dfac63aa2e9bb9a81697d4954e968b3990cf909&quot;,</span><br><span class="line">            &quot;sha256:4f17d163126ff1be561ac278bfa3510785f9b92d6c06a445518cf5764d1b595e&quot;,</span><br><span class="line">            &quot;sha256:8b185d674aeffdfbc67cd39ef9ce6970a615b816372575aaa64c5e8dcf343265&quot;,</span><br><span class="line">            &quot;sha256:eb6e8fe5c6dcab45fdddb8d87f8a860032e0b17e377b23dc5bf5dd7b639f464a&quot;,</span><br><span class="line">            &quot;sha256:1485ce09f58525e2feb2f46305a41b92f6ef419cb5407f4a63dc5118150e3120&quot;,</span><br><span class="line">            &quot;sha256:b654a29de9ee9eb506c668796e307573f7e5e9762d2fd4ecf890321577501d35&quot;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line"><span class="meta">#</span><span class="bash">以上时tomcat的所有的层，每一层对应每一个步骤</span></span><br></pre></td></tr></table></figure>
<h4 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h4><p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921215400377.png" alt=""></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921220014183.png" alt="image-20200921220014183"><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921220059867.png" alt="image-20200921220059867"><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921220107982.png" alt="image-20200921220107982"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200921220557568.png" alt="image-20200921220557568"></p>
<p><strong>2.特点</strong></p>
<p>docker镜像都是只读的</p>
<p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p>
<p>这一层通常被称作“容器层”，“容器层”之下都叫“镜像层”</p>
<h4 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit   #提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">命令和git原理类似</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</span><br><span class="line"><span class="meta">#</span><span class="bash">启动tomcat</span></span><br><span class="line">docker run -d --name tomcat02 -p 3355:8080 tomcat</span><br><span class="line">902a2d7b01ae82da6237976841759f21b6d550186271897c31e5bf0b1cc1ce99</span><br><span class="line"><span class="meta">#</span><span class="bash">修改容器</span></span><br><span class="line">[root@localhost ~]# docker exec -it 902a2d7b01ae /bin/bash</span><br><span class="line">root@902a2d7b01ae:/usr/local/tomcat# cp -r webapps.dist/* webapps</span><br><span class="line"><span class="meta">#</span><span class="bash">提交容器</span></span><br><span class="line">[root@localhost ~]# docker commit -a=&quot;admin_luo&quot; -m=&quot;add webapps app&quot; 902a2d7b01ae tomcat02:1.0</span><br><span class="line">sha256:9edbfbf50c79eb10a25afe359c00bc64f25accf8bf82fc08d87907e8ae4eaa67</span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器</span></span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat02              1.0                 9edbfbf50c79        8 seconds ago       652MB</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、启动一个默认的tomcat</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认webapps下面是没有文件的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、我自己拷贝进去基本的文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4、将我们操作过的容器通过commit提交为一个镜像  我们以后可以使用我们修改过的进行即可</span></span><br></pre></td></tr></table></figure>
<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><h4 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h4><p>产生背景：如果数据都存储再容器中，那么我们的容器一旦删除，数据就会丢失。==需求：数据可以持久化==</p>
<p>mysql：一旦容器删了，其中的数据也会删除==需求：mysql数据可以存储再本地==</p>
<p>容器之间有一个数据共享的技术：Docker容器中产生的数据同步到本地</p>
<p>这就是卷技术，目录的挂载，将我们容器内的目录，挂载到Linux上面（一种同步机制）</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200928113408308.png" alt="image-20200928113408308"></p>
<p><strong>容器的持久化和同步操作，容器之间也可以数据共享</strong></p>
<h4 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h4><blockquote>
<p>方式一：直接俄使用命令来挂载 -v  属性</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将容器内部的/home目录挂载到Linux上的/home/ceshi中</span></span><br><span class="line">[root@localhost ~]# docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">查看挂载情况：</span></span><br><span class="line">[root@localhost ~]# docker inspect 7c536fba4548</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/home/ceshi&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200928121518202.png" alt="image-20200928121518202"></p>
<h4 id="实战：安装mysql"><a href="#实战：安装mysql" class="headerlink" title="实战：安装mysql"></a>实战：安装mysql</h4><p>MySQL的数据持久化问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200929124942210.png" alt="image-20200929124942210"></p>
<h4 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">匿名挂载</span></span><br><span class="line">-v 容器内路径   # 只写容器内路径则会再外部随机创建一个目录与其挂载</span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line">a7821d87b202175cde7207b03065a9a937ee8501a751390fde857ff96782b2e8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有volume（数据卷）的情况</span></span><br><span class="line">[root@localhost ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               a80d776cc1e264df0e3453f34f5a25740087ef310cfee21089308a656c27b0df</span><br><span class="line">local               cd8171e5ab3b6611b2b53b5a47aa4827f1674d8aa999facdf584a6a0624d73b9</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这种就是匿名挂载，我们在-v只写了容器内的路径，没有i写容器外的路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">具名挂载</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">d0444da1c96079932c2de3fae1c86f5f929a0aea9e6a28b34453fee77efb6089</span><br><span class="line">[root@localhost ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               a80d776cc1e264df0e3453f34f5a25740087ef310cfee21089308a656c27b0df</span><br><span class="line">local               cd8171e5ab3b6611b2b53b5a47aa4827f1674d8aa999facdf584a6a0624d73b9</span><br><span class="line">local               juming-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过 -v    卷名：容器内路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看以下这个卷</span></span><br><span class="line">[root@localhost ~]# docker inspect juming-nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2020-09-30T11:22:41+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,           #路径</span><br><span class="line">        &quot;Name&quot;: &quot;juming-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所有的docker容器内的卷，没有指定目录的情况下都时在<code>var/lib/docker/volumes/xxxx(卷名)/_data</code></p>
<p>通过具名挂载可以方柏霓我们找到一个卷，大多数情况在使用<code>具名挂载</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如何确定时具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内路径   			 #匿名挂载</span><br><span class="line">-v 卷名：容器内路径  	   #具名挂载</span><br><span class="line">-v /宿主机路径：容器内路径  #指定路径挂载</span><br></pre></td></tr></table></figure>
<p>拓展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过 -v 容器内路径：ro   rw  改变读写权限</span></span><br><span class="line">ro  readonly  #只读</span><br><span class="line">rw  readwrite #可读可写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一旦设置了容器权限，容器对我们挂载出来的内容就有了限定</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ro说明这个路径只能通过宿主机来操作，容器内部无法操作</span></span><br></pre></td></tr></table></figure>
<h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><h4 id="初识dockerfile"><a href="#初识dockerfile" class="headerlink" title="初识dockerfile"></a>初识dockerfile</h4><p>Dockerfile就是用来docker镜像的构建文件，命令脚本</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个dockerfile文件，名字可以随意</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件中的内容   指令（大写）  参数</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]   #在创立的时候就将其挂载出来。【匿名挂载】</span><br><span class="line"></span><br><span class="line">CMD echo &quot;------end-----&quot;</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这里的每一个命令就是镜像的一层</span>                 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  .  代表生成在当前目录下</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930184513770.png" alt="image-20200930184513770"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930184835556.png" alt=""></p>
<p>这个卷和外部一定有一个同步的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@13c2a5ed112f /]# cd volume01</span><br><span class="line">[root@13c2a5ed112f volume01]# touch testfile</span><br><span class="line">[root@13c2a5ed112f volume01]# ls</span><br><span class="line">testfile</span><br><span class="line">[root@13c2a5ed112f volume01]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost dockerfile-test]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">13c2a5ed112f        923f2bcbcaf0        &quot;/bin/bash&quot;              8 minutes ago       Exited (0) About a minute ago                       unruffled_bhaskara</span><br><span class="line">d0444da1c960        nginx               &quot;/docker-entrypoint.…&quot;   8 hours ago         Exited (0) 7 hours ago                              nginx02</span><br><span class="line">a7821d87b202        nginx               &quot;/docker-entrypoint.…&quot;   8 hours ago         Exited (0) 7 hours ago                              nginx01</span><br><span class="line">[root@localhost dockerfile-test]# docker inspect 13c2a5ed112f</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930185652042.png" alt="image-20200930185652042"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerfile-test]# cd /var/lib/docker/volumes/7c295609fb1a192c2aded5e6869b19b0db428e16b0d7710c19f295c593de0179/_data</span><br><span class="line">[root@localhost _data]# ls</span><br><span class="line">testfile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现，在容器中创建的文件在容器外也可以访问</p>
<p>如果构建镜像的时候没有挂载卷，需要手动镜像挂载：  -v 卷名：容器内路径</p>
<h4 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h4><p>多个mysql同步数据</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930190340684.png" alt="image-20200930190340684"></p>
<p>利用父容器给别的容器共享数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动刚才创建的容器来进行实验：</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930190808701.png" alt="image-20200930190808701"></p>
<p><strong>通过==—volumes-from==可以实现容器之间的数据共享</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个docker02  并使用--volumes-from docker01</span> </span><br><span class="line">docker01中的操作：</span><br><span class="line">[root@abc9d6979c45 volume01]# touch docker01</span><br><span class="line">[root@abc9d6979c45 volume01]# ls</span><br><span class="line">docker01</span><br><span class="line"><span class="meta">#</span><span class="bash">在docker01中创建一个文件：在docker02中可以看到：如下图</span></span><br><span class="line">在docker02中创建文件，在docker01中也可以看到</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930192752679.png" alt="image-20200930192752679"></p>
<p>将docker01删除之后，docker02依然可以访问这个文件</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930194649056.png" alt="image-20200930194649056"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20200930194916305.png" alt="image-20200930194916305"></p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为之</p>
<p>但是一旦持久化到了本地，这个时候，本地的数据不会删除</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>dockerfile是用来构建docker镜像的文件，命令参数脚本</p>
<p>构建步骤</p>
<p>1、编写一个dockerfile文件</p>
<p>2、docker build 构建成为一个镜像</p>
<p>3、docker run 运行镜像</p>
<p>4、docker push发布镜像（DockerHub、阿里云镜像仓库）</p>
<p>很多官方镜像都是基础包，很多功能都没有。我们通常会自己搭建自己的镜像</p>
<h4 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h4><p><strong>基础知识</strong></p>
<ul>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行顺序为从上到下</li>
<li><h1 id="表示注释"><a href="#表示注释" class="headerlink" title="表示注释"></a>表示注释</h1></li>
<li>每个指令都会创建提交一个新的镜像层并提交</li>
</ul>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201002132830165.png" alt="image-20201002132830165"></p>
<p>dockerfile是面向开发的，我们以后发布项目（做镜像）就需要编写dockerfile文件</p>
<p>docker镜像逐渐成为企业交付的标准，必须要掌握</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201002133540727.png" alt="image-20201002133540727"></p>
<h4 id="dockerfile的指令"><a href="#dockerfile的指令" class="headerlink" title="dockerfile的指令"></a>dockerfile的指令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM   #基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER   #镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN          #镜像构建的时候需要运行的命令</span><br><span class="line">ADD			 #步骤：tomcat镜像，这个tomcat压缩包  添加内容</span><br><span class="line">WORKDIR		 #镜像的工作目录</span><br><span class="line">VOLUME    	 #挂载的目录</span><br><span class="line">EXPOSE 		 #暴露端口配置</span><br><span class="line">CMD			 #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT	 #指定这个容器启动的时候要运行的命令，可追加命令</span><br><span class="line">ONBUILD		 #当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令（触发指令）</span><br><span class="line">COPY		 #类似ADD，将我们的文件拷贝到镜像中</span><br><span class="line">ENV			 #构建的时候设置环境变量</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201002133708027.png" alt="image-20201002133708027"></p>
<h4 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h4><p>Docker Hub中99%的镜像都是从 scratch 这个基础镜像过来的，然后配置需要的软件和配置来进行构建</p>
<blockquote>
<p>创建一个自己的centos</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编写一个Dockerfile的文件</span><br><span class="line">[root@localhost dockerfile]# vim dockerfile</span><br><span class="line">[root@localhost dockerfile]# cat dockerfile </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER luo</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-toold</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、通过这个文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令 docker build -f dockerfile文件路径 -t 镜像名[版本号]</span></span><br><span class="line">[root@localhost dockerfile]# docker build -f mydockerfile-centos -t mycentos .</span><br><span class="line">Successfully built 5008b70c630d</span><br><span class="line">Successfully tagged mycentos:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、测试运行</span></span><br><span class="line">[root@localhost dockerfile]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mycentos              latest              5008b70c630d        8 minutes ago       295MB</span><br><span class="line">[root@localhost dockerfile]# docker run -it mycentos</span><br><span class="line">[root@7c219fc55116 local]# pwd</span><br><span class="line">/usr/local		#该目录是之前设置的工作目录，若没有设置，默认是根目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>docker history 可以列出本地进行的变更历史</p>
<blockquote>
<p>CMD 和 ENTRYPOINT区别</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMD		# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT	#指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerfile]# vim dockerfile-cmd-test</span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"></span><br><span class="line">[root@localhost dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class="line">[root@localhost dockerfile]# docker run -it a34f818465ec</span><br><span class="line">.   .dockerenv	dev  home  lib64       media  opt   root  sbin	sys  usr</span><br><span class="line">..  bin		etc  lib   lost+found  mnt    proc  run   srv	tmp  var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">想追加一个命令 -l  ls -al会报错：</span></span><br><span class="line">[root@localhost dockerfile]# docker run  a34f818465ec -l</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;-l\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line"><span class="meta">#</span><span class="bash">cmd的清理下 -l 替换了CMD[<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]命令。  -l 不是命令所以会产生报错</span></span><br></pre></td></tr></table></figure>
<p>测试ENTRYPOINT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerfile]# vim dockerfile-cmd-entrypoint</span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line">[root@localhost dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entroypoint-test</span><br><span class="line">[root@localhost dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entroypoint-test .</span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 0d120b6ccaa8</span></span><br><span class="line">Step 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 9b686907bb2d</span></span><br><span class="line">Removing intermediate container 9b686907bb2d</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ef7c96ff3b31</span></span><br><span class="line">Successfully built ef7c96ff3b31</span><br><span class="line">Successfully tagged entroypoint-test:latest</span><br><span class="line">[root@localhost dockerfile]# docker run entroypoint-test</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">追加命令是直接在ENTRYPOINT后面的</span></span><br><span class="line"></span><br><span class="line">[root@localhost dockerfile]# docker run entroypoint-test -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x.   1 root root   6 Oct  2 12:02 .</span><br><span class="line">drwxr-xr-x.   1 root root   6 Oct  2 12:02 ..</span><br><span class="line">-rwxr-xr-x.   1 root root   0 Oct  2 12:02 .dockerenv</span><br><span class="line">lrwxrwxrwx.   1 root root   7 May 11  2019 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x.   5 root root 340 Oct  2 12:02 dev</span><br><span class="line">drwxr-xr-x.   1 root root  66 Oct  2 12:02 etc</span><br><span class="line">drwxr-xr-x.   2 root root   6 May 11  2019 home</span><br><span class="line">lrwxrwxrwx.   1 root root   7 May 11  2019 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root   9 May 11  2019 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------.   2 root root   6 Aug  9 21:40 lost+found</span><br><span class="line">drwxr-xr-x.   2 root root   6 May 11  2019 media</span><br><span class="line">drwxr-xr-x.   2 root root   6 May 11  2019 mnt</span><br><span class="line">drwxr-xr-x.   2 root root   6 May 11  2019 opt</span><br><span class="line">dr-xr-xr-x. 133 root root   0 Oct  2 12:02 proc</span><br><span class="line">dr-xr-x---.   2 root root 162 Aug  9 21:40 root</span><br><span class="line">drwxr-xr-x.  11 root root 163 Aug  9 21:40 run</span><br><span class="line">lrwxrwxrwx.   1 root root   8 May 11  2019 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root   6 May 11  2019 srv</span><br><span class="line">dr-xr-xr-x.  13 root root   0 Oct  2 06:04 sys</span><br><span class="line">drwxrwxrwt.   7 root root 145 Aug  9 21:40 tmp</span><br><span class="line">drwxr-xr-x.  12 root root 144 Aug  9 21:40 usr</span><br><span class="line">drwxr-xr-x.  20 root root 262 Aug  9 21:40 var</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dockerfile中许多命令十分相似，我们需要了解其区别，最好是对比学习</p>
<h4 id="实战：tomcat镜像"><a href="#实战：tomcat镜像" class="headerlink" title="实战：tomcat镜像"></a>实战：tomcat镜像</h4><p>1、准备镜像文件 tomcat压缩包，jdk的压缩包</p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201007131537038.png" alt="image-20201007131537038"></p>
<p>2、编写dockerfile文件  ，  官方名命==Dokcerfile==，build 的时候会自动寻找这个文件，就不需要-f进行指定了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# cat Dockerfile </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER luoxy</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u251-linux-x64.tar.gz /usr/local</span><br><span class="line">ADD apache-tomcat-9.0.38.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_251</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.38</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 ADD会自动解压</p>
<p>CATALINA  为toncat 的默认目录</p>
<p>3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">docker build -t diytomcat .</span></span><br></pre></td></tr></table></figure>
<p>4、启动镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker run -d -p 9090:8080 --name luoxytomcat -v /home/luoxy/build/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps/test -v /home/luoxy/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.38/logs diytomcat</span><br><span class="line">1bf0c4d1df0d2e65f11acc90a9d51f945f06f6750319c0df2aabd29380e36872</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、访问测试</p>
<p>6、发布项目（由于做了卷的挂载，我们可以直接在本地发布项目)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.4&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;web logs&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(&quot;------my test web logs-----&quot;);</span><br><span class="line"><span class="meta">%</span><span class="bash">&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>通过以上步骤，项目部署成功</p>
<h4 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h4><blockquote>
<p>Dockerhub</p>
</blockquote>
<p>1、地址： <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>2、在centos中提交镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:	docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、登录完毕之后就可以提交镜像了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker login -u 1297725225</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">提交前需要先修改镜像名：</span></span><br><span class="line">[root@localhost ~]# docker tag f1fca8e2d444   1297725225/tomcat</span><br><span class="line">[root@localhost ~]# docker push 1297725225/tomcat</span><br><span class="line">The push refers to repository [docker.io/1297725225/tomcat]</span><br><span class="line">dbe8804e9957: Pushed </span><br><span class="line">b5079a1d0008: Pushed </span><br><span class="line">285cb2d1a9e3: Pushing [=========================&gt;                         ]    203MB/405.8MB</span><br><span class="line">bff150372ed8: Pushed </span><br><span class="line">291f6e44771a: Pushed </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201007212605138.png" alt="image-20201007212605138"></p>
<p><img src="C:\Users\AdminLuo\AppData\Roaming\Typora\typora-user-images\image-20201007212913986.png" alt="image-20201007212913986"></p>
<h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p>企业实战</p>
<p>Docker Compose</p>
<p>Docker Swarm</p>
<p>CI/CD   Jenkins  流水线</p>
]]></content>
  </entry>
</search>
